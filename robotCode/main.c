#pragma config(Sensor, in1,    motor1_angle,    sensorPotentiometer)
#pragma config(Sensor, in2,    motor2_angle,    sensorPotentiometer)
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port10,           motor2,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//MAX_SENSOR, used as a comparitively LOW sensor value when beaming for beacon.
int MAX_SENSOR = 0;
//393_SPEED, used as a standard speed to run the VEX 393 drive motors.
int 393_SPEED = 25;

//unload: deposits object on top of beacon.
void unload () {

}

//drive: drives in a straight line.
void drive () {
    motor[motor1] = 393_SPEED;
    motor[motor2] = -393_SPEED;
}

//stop: stops drive motors.
void stop () {
    motor[motor1] = 0;
    motor[motor2] = 0;
}

//sentry: spins the robot in a circle, returns true when robot is pointing towards beacon. brings robot to a stop and spins.
bool sentry () {
    //stop robot.
    stop();
    //set motors to equal speeds. since the motors are opposed, setting them to equal speeds causes rotation.
    motor[motor1] = 393_SPEED;
    motor[motor2] = 393_SPEED;
    if (MAX_SENSOR == 0) {
        //do this if this is the first time scanning.
    } else if () {
        
    }
}

//beam: used to read sensor value and determine if robot is on correct path. 
void beam () {

}

task main () {
	
    enum robotState {
		STOP = 0,
        MOVING = 1,
		ON_TARGET = 2,
		OFF_TARGET = 3,
	};

	robotState state = MOTOR_STOP;
    drive();
    while (1) {
        // switch (state) {
        //     case STOP:
        //         break;
        //     case MOVING:
        //         break;
        //     case ON_TARGET:
        //         drive();
        //         break;
        //     case OFF_TARGET:
        //         stop();
        //         break;
        // }
    }
}
