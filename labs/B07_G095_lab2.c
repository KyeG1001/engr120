#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// WHEN YOU FINISH EACH EXERCISE, INCREMENT THIS VALUE
#define EXERCISE_NUMBER 	3

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input


/* monitorInput()
*
*  Used to flag button inputs
*       - this avoids errors caused by program recognizing input, taking action, and
*         reading input again before button is released
*/
void monitorInput()
{
  if(SensorValue(button1) && !button1_pushed)
  {
    button1_pushed = true;
  }

  if(SensorValue(button2) && !button2_pushed)
  {
    button2_pushed = true;
  }
}

void exercise_1()
{
	// Define tag for enumerated type for exercise 1
	enum T_exercise1_state {
		MOTOR_STOP = 0,
		MOTOR_RUNNING = 1
	};

	// Declare variable to hold state, intialize to MOTOR_STOP state.
	T_exercise1_state exercise1_state = MOTOR_STOP;

	while(true)
	{
		// This function updates the button1_pushed and button2_pushed flags.
		monitorInput();

		// Switch the states.
		switch(exercise1_state) {

			// Code for MOTOR_STOP state:
		case MOTOR_STOP:
			// Turn motor off.
			motor[motor1] = 0;
			if ( button1_pushed ) {
				// If button1 pushed, change to the MOTOR_RUNNING state.
				exercise1_state = MOTOR_RUNNING;
				// Clear flag to indicate button 1 processed.
				button1_pushed = false;
			}
			break;
		case MOTOR_RUNNING:
			// Turn motor on.
			motor[motor1] = 50;
			if (button2_pushed) {
				// If button 2 pushed, transition to MOTOR_STOP state.
				exercise1_state = MOTOR_STOP;
				// Clear flag to indicate that button 2 processed.
				button2_pushed = false;
			}
			break;
		default:
		}

	}//end while
}

void exercise_2()
{
	// Define tag for enumerated type for exercise 2
	enum T_exercise2_state {
		MOTOR_STOP = 0,
		MOTOR_RUNNING = 1

	};

	// Declare variable to hold state, intialize to MOTOR_STOP state.
	T_exercise2_state exercise2_state = MOTOR_STOP;

  while(true)
  {
    monitorInput();

		// Switch the states.
		switch(exercise2_state) {

			// Code for MOTOR_STOP state:
		case MOTOR_STOP:
			// Turn motor off.
			motor[motor1] = 0;
			// Reset motor encoder.
			resetMotorEncoder(motor1);
			if ( button1_pushed ) {
				// If button1 pushed, change to the MOTOR_RUNNING state.
				exercise2_state = MOTOR_RUNNING;
				// Clear flag to indicate button 1 processed.
				button1_pushed = false;
			}
			break;
		case MOTOR_RUNNING:
			// Turn motor on.
			motor[motor1] = 50;
			// Once motor has reached tick 627, transition to MOTOR_STOP state.
			//writeDebugStream("%d\n", getMotorEncoder(motor1));
			if (getMotorEncoder(motor1) > 627) {
				exercise2_state = MOTOR_STOP;
			}
			break;
			default:
			}

    }// end while

} // end exercise_2

void exercise_3()
{
	// Define tag for enumerated type for exercise 3
	enum T_exercise3_state {
		MOTOR_STOP = 0,
		MOTOR_FORW = 1,
		MOTOR_BACK = 2,
		MOTOR_FORW_B2 = 3,
		MOTOR_BACK_B1 = 4


	};

	// Declare variable to hold state, intialize to MOTOR_STOP state.
	T_exercise3_state exercise3_state = MOTOR_STOP;

  while(true)
  {
    monitorInput();
		writeDebugStream("%d\n", exercise3_state);
		// Switch the states.
		switch(exercise3_state) {

			// Code for MOTOR_STOP state:
		case MOTOR_STOP:
			// Turn motor off.
			motor[motor1] = 0;
			//Reset motor encoder.
			resetMotorEncoder(motor1);
			if ( button1_pushed ) {
				// If button1 pushed, change to the MOTOR_FORW state.
				exercise3_state = MOTOR_FORW;
				// Clear flag to indicate button 1 processed.
				button1_pushed = false;
			} else if (button2_pushed) {
				// If button2 pushed, change to the MOTOR_BACK state.
				exercise3_state = MOTOR_BACK;
				// Clear flag to indicate button 2 processed.
				button2_pushed = false;
			}
			break;
		case MOTOR_FORW:
			// Turn motor on forwards.
			motor[motor1] = 50;
			if (getMotorEncoder(motor1) > 3000) {
				// Once motor has reached tick 3000, transition to MOTOR_STOP state.
				exercise3_state = MOTOR_STOP;
			}
			if (button2_pushed) {
				// If button2 pushed during forward movement, change to the MOTOR_FORW_B2 state.
				exercise3_state = MOTOR_FORW_B2;
				// Clear flag to indicate button 2 processed.
				button2_pushed = false;
			}
			break;
		case MOTOR_BACK:
			// Turn motor on backwards.
			motor[motor1] = -50;
			if (getMotorEncoder(motor1) < -3000) {
				// Once motor has reached tick 3000, transition to MOTOR_STOP state.
				exercise3_state = MOTOR_STOP;
			}
			if (button1_pushed) {
				// If button1 pushed during forward movement, change to the MOTOR_BACK_B1 state.
				exercise3_state = MOTOR_BACK_B1;
				// Clear flag to indicate button 1 processed.
				button1_pushed = false;
			}
			break;
		case MOTOR_FORW_B2:
			//Once motor has reached tick 3000, transition to MOTOR_BACK state.
			if (getMotorEncoder(motor1) > 3000) {
				button1_pushed = false;
				button2_pushed = false;
				exercise3_state = MOTOR_BACK;
			}
			break;
		case MOTOR_BACK_B1:
			//Once motor has reached tick 3000, transition to MOTOR_FORW state.
			if (getMotorEncoder(motor1) < -3000) {
				button1_pushed = false;
				button2_pushed = false;
				exercise3_state = MOTOR_FORW;
			}
			break;
			default:
			}

    }// end while

}//end exercse_3


task main()
{
	button1_pushed = button2_pushed = false;

	switch (EXERCISE_NUMBER)
  {
     case 1:
       exercise_1();
       break;
     case 2:
       exercise_2();
       break;
     case 3:
       exercise_3();
       break;
     default: //should never get here.
   } // end switch

}// end main
